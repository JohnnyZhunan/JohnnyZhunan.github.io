






<!doctype html>
<html lang="zh-CN">
<head>
  <meta http-equiv="Content-Type" content="text/html" charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <meta name="author" content="Johnny Zhu">
  
  
  
  
    <meta name="description" content="Unity生命周期在网上一顿找，找到了这个这个图，是我有史以来见到的最为详尽的一个介绍生命周期的图，这幅图来自这篇链接：Unity生命周期


在看这副图的时候，再结合这个链接：Unity生命周期顺便将一些关键的介绍贴出来：最先执行的方法是Awake，这是生命周期的开始，用于进行激活时的初始化代码，一般可以在这个地方将当前脚本禁用:this.enable=false，如果这样做了，则会直接跳...">
  
  <title>Unity使用总结（五） [ Johnny Zhu's Blog ]</title>
  
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  
  <link rel="stylesheet" href="/css/random.css">
<link rel="stylesheet" href="/css/vegas.min.css">
<link rel="stylesheet" href="/css/highlight-railscasts.css">
<link rel="stylesheet" href="/css/jquery.fancybox.css">
<link rel="stylesheet" href="/css/iconfont/iconfont.css">
<link rel="stylesheet" href="/css/jquery.fancybox-thumbs.css">
<link rel="stylesheet" href="/css/plyr.css">
  
</head>

<body>
<div class="side-navigate hide-area">
  
  
    <div class="item next">
      <a href="/2018/05/05/Unity总结（四）/">
        <div class="item-icon"></div>
      </a>
      <div class="item-title">
        Unity总结（四）
      </div>
    </div>
  
</div>
<div id="outer-container" class="hide-area">
<div id="container">
  <div id="menu-outer" class="slide-down">
    <div id="menu-inner">
      <div id="brand">
        
        <a onClick="openUserCard()">
          <img id="avatar" src="/pic/head.jpg"/>
          <div id="homelink">Johnny Zhu's Blog</div>
        </a>
      </div>
      <div id="menu-list">
        <ul>
        
        
          
            <li>
          
            <a href="/index.html">主页</a>
            
          </li>
        
          
            <li>
          
            <a href="/archives">所有文章</a>
            
          </li>
        
          
            <li>
          
            <a href="/tags">标签</a>
            
          </li>
        
          
            <li>
          
            <a href="/categories">分类</a>
            
          </li>
        
          
            <li>
          
            <a href="/about">关于我</a>
            
          </li>
        
        </ul>
      </div>
      <div id="show-menu">
        <button>Menu</button>
      </div>
    </div>
  </div>

  <div id="content-outer">
    <div id="content-inner">
      
      
  <article id="post">
    <h1>Unity使用总结（五）</h1>
    <p class="page-title-sub">
      <span id = "post-title-date">撰写于 2018-05-12</span>
      
        <span id = "post-title-updated">修改于 2018-05-12</span>
      
      
      <span id = "post-title-categories">分类
      
      
        
        
        <a href="/categories/2018年5月/">2018年5月</a>
      
      </span>
      
      
      <span id = "post-title-tags">
      标签
      
      
        
        
        <a href="/tags/Unity/">Unity</a>
      
        
          /
        
        
        <a href="/tags/C/">C#</a>
      
      </span>
      
    </p>
    
    <h2 id="Unity生命周期"><a href="#Unity生命周期" class="headerlink" title="Unity生命周期"></a>Unity生命周期</h2><p>在网上一顿找，找到了这个这个图，是我有史以来见到的最为详尽的一个介绍生命周期的图，这幅图来自这篇链接：<br><a href="www.xuanyusong.com/archives/3225">Unity生命周期</a></p>
<div align="center"><br><br><img src="http://p4cjhhn4q.bkt.clouddn.com/%E5%9B%BE1.jpg" alt="图一"><br><br></div>

<p>在看这副图的时候，再结合这个链接：<br><a href="https://blog.csdn.net/qitian67/article/details/18516503" target="_blank" rel="noopener">Unity生命周期</a><br>顺便将一些关键的介绍贴出来：<br>最先执行的方法是Awake，这是生命周期的开始，用于进行激活时的初始化代码，一般可以在这个地方将当前脚本禁用:this.enable=false，如果这样做了，则会直接跳转到OnDisable方法执行一次，然后其它的任何方法，都将不再被执行。<br>如果当前脚本处于可用状态，则正常的执行顺序是继续向下执行OnEnable，当然我们可以在另外一个脚本中实现这个脚本组件的启动：this.enab=true;<br>再向下执行，会进行一个判断，如果Start方法还没有被执行，则会被执行一次，如果已经被执行了，则不会再被执行。这是个什么意思呢？我们可以在某个脚本中将组件禁用this.enable=false，再启用时会转到OnEnable处执行，这时继续向下走，发现Start执行过了，将不再被执行。比如说：第一次启用时，将怪物的初始位置定在了(0,0,0)点，然后怪物可能会发生了位置的变换，后来被禁用了，再次启用时，不会让怪物又回到初始的(0,0,0)位置。<br>继续向后执行，就是Update了，然后是FixUpdate，再然后是LateUpdate，如果后面写了Reset，则会又回到Update，在这4个事件间可以进行循环流动。<br>再向后执行，就进入了渲染模块（Rendering），非常重要的一个方法就是OnGUI，用于绘制图形界面。当然，如果你使用了NGUI，这个生命周期的事情你就不用考虑了。<br>再向后，就是卸载模块（TearDown），这里主要有两个方法OnDisable与OnDestroy。当被禁用(enable=false)时，会执行OnDisable方法，但是这个时候，脚本并不会被销毁，在这个状态下，可以重新回到OnEnable状态（enable=true）。当手动销毁或附属的游戏对象被销毁时，OnDestroy才会被执行，当前脚本的生命周期结束。</p>
<p>特别要强调的是：这里虽然可以使用C#来写代码，但是这个类构造对象的生命周期，与MonoBehaviour的生命周期，是完全不同的。</p>
<h2 id="LateUpdate-Update-FixedUpdate"><a href="#LateUpdate-Update-FixedUpdate" class="headerlink" title="LateUpdate/Update/FixedUpdate"></a>LateUpdate/Update/FixedUpdate</h2><p>在生命周期当中，这三个经常被拿出来用来比较，具体什么区别和联系，我觉得这个链接介绍的比较详细：<br><a href="https://blog.csdn.net/w1095471150/article/details/52511398" target="_blank" rel="noopener">关于unity中的update、Lateupdate和FixedUpdate</a></p>
<h2 id="C-当中的属性"><a href="#C-当中的属性" class="headerlink" title="C#当中的属性"></a>C#当中的属性</h2><p>在本周的工作当中，尝试着用了一下同事给我介绍的Screen.currentResolution，虽然事后证明，这个东西并没有在我的工作当中起到多大的作用，但是我却因此了解了一下C#当中的属性，因为Screen.currentResolution本质上就是属性。<br>关于属性，我觉得还是msdn官网介绍的比较好，参考这个链接：<br><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/using-properties" target="_blank" rel="noopener">使用属性（C# 编程指南）</a></p>
<h2 id="对UIPanel-的-clipping和Anchors的理解"><a href="#对UIPanel-的-clipping和Anchors的理解" class="headerlink" title="对UIPanel 的 clipping和Anchors的理解"></a>对UIPanel 的 clipping和Anchors的理解</h2><p>我在使用NGUI的时候，总是被UIPanel坑的很惨，我觉得截止目前，我也对UIPanel理解的并不是特别到位，尤其是在使用clipping和Anchors的时候，我个人的理解，对于UIPanel的Anchors，有别于其它的Anchors，它更偏向于是一个“范围”，即：限定你的裁剪区域，这就是为什么，只有在Clipping不为None的时候，Anchors才可以被选择。<br>关于Clipping的解释，我查了一些资料，认为这个解释比较好：<br>Clipping 是剪辑窗口的意思，它可以让一个面板只显示某一块区域，这个功能在 ScrollView 滚动框或者滚动列表中非常有用。Clipping 一共提供了 3 中模式：<br>（1）None:无剪辑模式，在这种模式下，滚动视框中的物体可以被拖动，但是视窗因为没有剪辑，所以是没有边界的。这将可能导致内容被拖出屏幕外再也拖不回来。就像我们往下拖动浏览网页时会拖到一个所谓的“底”，None 模式就是没有这个“底”，你可以将内容全部拖出屏幕以外。<br>（2）SoftClip：柔和剪辑模式，我们一般都会使用这种模式来制作 ScrollView。在这种模式下，Panel 将会剪辑出一块可视区域出来显示，这个被剪辑出来的区域以外的部分将会被剪辑掉而无法显示出来。<br>（3）Constrain but don’t Clip:这种模式是指视窗会尽量地包含所有的内容，但是不剪辑它们，效果大约等同于有边界但是边界为全屏，无法完全将内容拖到屏幕外面去，只要在屏幕范围内，都能看到内容，内容并不会被剪辑掉。</p>
<p>以上摘自这个链接：<br><a href="www.cnblogs.com/msxh/p/6574554.html">【Unity游戏开发】浅谈 NGUI 中的 UIRoot、UIPanel、UICamera 组件 </a><br>这个链接，对UIRoot,UIPanel,UICamera介绍的都非常的详尽，用的时候再深入了解一下~<br>在使用UIPanel的时候，发现UIPanel的坑也实在是多，如果你原来已经设置好Anchors的情况下，突然改变锚点，或者将clipping设置为none，UIPanel的范围就会突然变形，甚至还会不由自主的自行移动，针对这个问题，建议最好新建一个临时的widget，将这个UIPanel给固定住，然后再设置你想要的锚点。<br>此外，在使用UIPanel的Anchors的时候，当中的Execute似乎不是那么容易起作用，比如，我在工作中就发现，即使你在Execute当中选择了Update，它似乎也无法做到每一帧都刷新一次，为了解决这个问题，我查看了一下NGUI当中的UIPanel.cs，发现了几个Update方法，经过几次试验，发现只要在代码当中加入：ResetAndUpdateAnchors()函数，这个函数其实来自于UIRect.cs，不过，因为UIPanel.cs继承自UIRect.cs方法，所以，用UIPanel类型的变量就可以直接调用该方法，即可实现每一帧的更新。</p>
<h2 id="获取组件，以及通过组件找GameObject"><a href="#获取组件，以及通过组件找GameObject" class="headerlink" title="获取组件，以及通过组件找GameObject"></a>获取组件，以及通过组件找GameObject</h2><p>你如果想获取一个物体上的组件，假设这个物体是gameObject，那么用gameOb.GetComponent&lt;组件的类别&gt;()方法，即可获取这个组件对象。<br>如果你想通过组件来获取挂载该组件的gameObject，那么，你只需这样写就可以了（假设这个组件是UIPanel类型的变量uiPanel）：</p>
<div align="center"><br>uiPanel.gameObject;<br></div>

<h2 id="如何获取Game-Viewer的视图大小"><a href="#如何获取Game-Viewer的视图大小" class="headerlink" title="如何获取Game Viewer的视图大小"></a>如何获取Game Viewer的视图大小</h2><p>Unity提供了Screen.width和Screen.height，当你调用这两个属性的时候，就可以获取GameViewer视图的宽和高。<br>如果你在Update（）当中使用它们，并且打上Debug.Log日志，然后运行Unity，在GameViewer视图当中，将屏幕比例改成Free Aspect，那么当你拖动GameViewer窗口的时候，通过你的日志，你就会发现，屏幕的宽和高真的在实时的发生变化。</p>

  </article>
  <div class="random-toc-area">
  <button class="btn-hide-toc btn-hide-toc-show" style="display: none" onclick="TOCToggle()">显示目录</button>
  <button class="btn-hide-toc btn-hide-toc-hide" onclick="TOCToggle()">隐藏目录</button>
  <div class="random-toc">
    <h2>目录</h2>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Unity生命周期"><span class="toc-text">Unity生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LateUpdate-Update-FixedUpdate"><span class="toc-text">LateUpdate/Update/FixedUpdate</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-当中的属性"><span class="toc-text">C#当中的属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对UIPanel-的-clipping和Anchors的理解"><span class="toc-text">对UIPanel 的 clipping和Anchors的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#获取组件，以及通过组件找GameObject"><span class="toc-text">获取组件，以及通过组件找GameObject</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何获取Game-Viewer的视图大小"><span class="toc-text">如何获取Game Viewer的视图大小</span></a></li></ol>
  </div>
</div>

  
<nav id="pagination">
  

  

  
    <a href="/2018/05/05/Unity总结（四）/" class="next">下一篇 Unity总结（四） &rarr;</a>
  
</nav>

  <!-- JiaThis Button BEGIN -->

<!-- JiaThis Button END -->


      
      
    </div>
  </div>

  <div id="bottom-outer">
    <div id="bottom-inner">
      Site by Johnny Zhu using
      <a href="http://hexo.io">Hexo</a> & <a href="https://github.com/stiekel/hexo-theme-random">Random</a>
      <br>
      
    </div>
  </div>
</div>

</div>


<div id="user-card">
  <div class="center-field">
    <img class="avatar" src="/pic/head.jpg">
    <p id="description"></p>
    <ul class="social-icon">
  
  
    <li>
      <a href="https://github.com/JohnnyZhunan">
        
          <i class="icon iconfont github">&#xe606;</i>
        
      </a>
    </li>
  
    <li>
      <a href="https://weibo.com/5547714305/profile?rightmod=1&wvr=6&mod=personinfo">
        
          <i class="icon iconfont weibo">&#xe602;</i>
        
      </a>
    </li>
  
</ul>
  </div>
</div>


<script>
// is trigger analytics / tongji script
var isIgnoreHost = false;

if(window && window.location && window.location.host) {
  isIgnoreHost = ["localhost","127.0.0.1"].some(function(address){
    return 0 === window.location.host.indexOf(address);
  });
}

var isTriggerAnalytics = !( true && isIgnoreHost );

</script>




  
  
    <script src="/js/jquery-2.2.3.min.js"></script>
  
    <script src="/js/vegas.min.js"></script>
  
    <script src="/js/random.js"></script>
  
    <script src="/js/highlight.pack.js"></script>
  
    <script src="/js/jquery.mousewheel.pack.js"></script>
  
    <script src="/js/jquery.fancybox.pack.js"></script>
  
    <script src="/js/jquery.fancybox-thumbs.js"></script>
  
    <script src="/js/plyr.js"></script>
  

<script>

  // fancybox
  var backgroundImages = [];
  
  $('#post').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox') || $(this).parent().hasClass('fancybox-thumb')) return;
      var alt = this.alt || this.title;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'post' + i);
    });
  });
  $(".fancybox").fancybox();

var vegasConfig = {"preload­Image":true,"transition":["slideLeft2","slideRight2","flash2"],"timer":true,"delay":5000,"shuffle":true,"count":28};
var unsplashConfig = {"gravity":"north"};
// is show background images
var turnoffBackgroundImage = false;



  turnoffBackgroundImage = true;


var backgroundColor = "34495E";

$(".fancybox-thumb").fancybox({
  prevEffect: 'none',
  nextEffect: 'none',
  helpers: {
    title: {
      type: 'outside'
    },
    thumbs: {
      width: 50,
      height: 50
    }
  }
});

// show video with plyr
$(".video-container iframe").each(function(i){
  var url = $(this).attr('src');
  var id = url.split('/').pop();
  var plyrContainer = document.createElement('div');
  plyrContainer.className = 'plyr';
  var plyrElement = document.createElement('div');
  plyrElement.dataset.videoId = id;
  switch(true) {
    case url.search('youtube.com') >= 0:
      plyrElement.dataset.type = 'youtube';
      break;
    case url.search('vimeo.com') >= 0:
      plyrElement.dataset.type = 'vimeo';
      break;
    default:
      return;
  };
  plyrContainer.appendChild(plyrElement);
  $(this).parent().html(plyrContainer);
});
plyr.setup('.plyr', {iconUrl: '/css/sprite.svg'});
</script>
</body>
</html>

